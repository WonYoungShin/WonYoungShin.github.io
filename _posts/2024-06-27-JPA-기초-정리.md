---
layout: post
date: 2024-06-27
title: "JPA 기초 정리"
tags: [JPA, ]
categories: [ORM, ]
---



## JPA ( Java Persistence API ) 



#### 개요

- 자바 객체와 데이터베이스 간의 매핑을 관리하는 자바 표준 ORM (Object-Relational Mapping) 프레임워크
- JPA를 사용하면 데이터베이스와 상호작용할 때 SQL 쿼리를 작성할 필요 없이 자바 객체를 통해 데이터베이스 작업을 수행할 수 있다.


### JPA의 사용 이유



#### **생산성 향상**

- JPA를 사용하면 데이터베이스 연동을 위한 반복적인 SQL 코드를 작성할 필요가 없음
- 객체지향적으로 데이터를 관리할 수 있어 코드의 가독성과 유지보수성이 향상


#### **유지보수 용이성**

- 데이터베이스 테이블 구조가 변경되더라도, 엔터티 클래스만 수정하면 되므로 애플리케이션 코드의 수정이 최소화


#### **데이터베이스 독립성**

- JPA는 데이터베이스 독립적인 방식으로 작동
- 특정 데이터베이스에 종속되지 않기 때문에, 데이터베이스를 변경하더라도 애플리케이션 코드에 큰 영향이 없다.


#### **캐싱 및 성능 최적화**

- JPA는 1차 캐시와 2차 캐시를 제공하여 데이터베이스 접근 횟수를 줄이고 성능을 최적화할 수 있다.


#### **트랜잭션 관리**

- JPA는 트랜잭션 관리를 자동으로 처리하여 개발자가 트랜잭션 경계를 명시적으로 정의할 필요가 없다.


#### **표준화된 API**

- JPA는 자바 표준 API이기 때문에, JPA를 지원하는 다양한 구현체(Hibernate, EclipseLink 등)를 쉽게 교체할 수 있다. 이로인해 유연성과 확장성을 제공됨.


### JPA의 주요 구성 요소



#### **엔터티 (Entity)**

- 데이터베이스 테이블에 매핑되는 클래스입니다. 각 Entity는 데이터베이스의 테이블을 나타내며, 클래스의 각 필드는 테이블의 컬럼에 매핑 된다.


#### **엔터티 매니저 (Entity Manager)**

- Entity를 생성, 읽기, 업데이트 및 삭제하기 위해 사용되는 인터페이스입니다. **Entity Manager**는 EntityManagerFactory 를 통해 생성.


#### **영속성 컨텍스트 (Persistence Context)**

- **Entity Manager**가 관리하는 Entity 인스턴스의 집합입니다. 영속성 컨텍스트는 Entity의 생명주기를 관리


#### **쿼리 언어 (JPQL - Java Persistence Query Language)**

- 객체 지향 쿼리 언어로, 데이터베이스 테이블이 아닌 Entity 객체를 대상으로 쿼리를 작성합니다.

	> 📌 JPQL (Java Persistence Query Language) 이란  
	> - JPQ 는 SQL을 추상화한 JPQL 이라는 객체 지향 쿼리 언어 제공 (객체 지향 SQL)  
	>   
	> - 테이블을 대상으로 쿼리 하는 것이 아닌 엔티티 객체를 대상으로 쿼리  
	>   
	> - JPQL은 SQL을 추상화했기 때문에 특정 데이터베이스 SQL에 의존하지 않는 장점  
	>   
	> - SQL 과 문법 유사 ( SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원 )

		- JPQ 는 SQL을 추상화한 JPQL 이라는 객체 지향 쿼리 언어 제공 (객체 지향 SQL)
		- 테이블을 대상으로 쿼리 하는 것이 아닌 엔티티 객체를 대상으로 쿼리
		- JPQL은 SQL을 추상화했기 때문에 특정 데이터베이스 SQL에 의존하지 않는 장점
		- SQL 과 문법 유사 ( SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원 )


### JPA 구동방식

- JPA 는 Persistence 라는 클래스에서 시작한다. 설정정보(META-INF/persistence.xml)를 읽어서 EntityManagerFactory라는 클래스를 생성
- `EntityManagerFactory` 생성시 데이터베이스 연결 등 설정과 관련된 처리가 진행
- EntityManagerFactory 에서는 매 클라이언트의 요청에 따른 DB 처리시 EntityManager 를 생성
- `EntityManager` 는 쓰레드간에 절대로 공유해서 사용하면 안된다.
- 애플리케이션이 완전히 종료될 때, EntityManagerFactory 를 닫아줘야 한다.

	![0](/assets/img/2024-06-27-JPA-기초-정리.md/0.png)


---



## 영속성 컨텍스트( Persistence Context )

- "엔티티를 영구 저장하는 환경" ,엔터티의 상태를 관리하는 일종의 저장소 역할
- EntityManager 를 통해서 영속성 컨텍스트에 접근
	- EntityManager 를 생성하면, 그 안에 PersistenceContext(영속성 컨텍스트)라는 눈에 보이지 않는 논리적 개념의 공간이 생긴다.
	- Entity 의 생명주기(Lifecycle)를 관리
- EntityManager 를 통해 persist(..) 와 같은 작업을 한다고 해서 곧바로 INSERT 쿼리가 DB에 전달되지 않는다.
	- 해당 엔티티 객체는 영속성 컨텍스트의 관리 대상이 되는 상태인 영속 상태가 된다.
- 영속성 컨텍스트의 역할
	- 엔터티 인스턴스의 생명주기를 관리
	- 엔터티를 데이터베이스와 동기화
	- 트랜잭션 범위 내에서 엔터티의 변경 사항을 추적
	- 1차 캐시로서 엔터티를 캐싱하여 성능을 향상
- **엔터티의 생명주기**
	- **비영속 상태 (new / Transient):** 엔터티가 새로 생성되었지만 아직 영속성 컨텍스트에 의해 관리되지 않는 상태
	- **영속 상태 (Persistent):** 엔터티가 영속성 컨텍스트에 의해 관리되는 상태. 데이터베이스와 동기화
	- **준영속 상태 (Detached):** 영속성 컨텍스트에서 분리된 엔터티. 더 이상 영속성 컨텍스트에 의해 관리되지 않지만 데이터베이스에 여전히 존재

		> 📌 **준영속 상태**  
		> - 영속 -> 준영속  
		> - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)     
		> - 영속성 컨텍스트가 제공하는 기능(Dirty Checking, .. 등등)을 사용 못함     
		> - 준영속 상태로 만드는 방법
		>		- `em.detach(entity)` : 특정 엔티티만 준영속 상태로 전환
		>		- `em.clear()` : 영속성 컨텍스트를 완전히 초기화
		>		- `em.close()` : 영속성 컨텍스트를 종료
	- **삭제 상태 (Removed):** 삭제된 상태


### 영속성 컨텍스트의 주요 기능

- **엔터티의 저장 (Persist)**
	- `persist` 메서드를 사용하여 엔터티를 영속 상태로 만듭니다. 엔터티는 영속성 컨텍스트에 저장되고, 트랜잭션이 커밋될 때 데이터베이스에 반영됩니다.
- **엔터티의 조회 (Find)**
	- `find` 메서드를 사용하여 엔터티를 조회합니다. 영속성 컨텍스트에 존재하는 엔터티를 먼저 검색하고, 없으면 데이터베이스에서 조회합니다.
- **엔터티의 병합 (Merge)**
	- `merge` 메서드를 사용하여 준영속 상태의 엔터티를 다시 영속 상태로 만듭니다. 준영속 상태의 엔터티를 영속성 컨텍스트에 병합하고, 변경된 값을 데이터베이스에 반영합니다.
- **엔터티의 삭제 (Remove)**
	- `remove` 메서드를 사용하여 엔터티를 삭제합니다. 영속성 컨텍스트와 데이터베이스에서 엔터티를 제거합니다.
- **영속성 컨텍스트의 플러시 (Flush)**
	- `flush` 메서드를 사용하여 영속성 컨텍스트의 변경 사항을 강제로 데이터베이스에 반영합니다. 이는 트랜잭션이 커밋되기 전에 변경 사항을 데이터베이스에 반영할 때 사용됩니다.

		> 📌 flush  
		> - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영  
		> - flush 발생시  
		> - 영속성 컨텍스트를 플러시하는 방법  
		>		- `em.flush()` : 직접 호출
		>		- 트랜잭션 커밋 : 플러시 자동 호출
		>		- JPQL 쿼리 실행 : 플러시 자동 호출
		>		- `flush()` 가 발생한다고 해서 데이터베이스 트랜잭션이 커밋되는 것은 아니다.
		>		- `flush()` 가 발생한다고 해서 1차 캐시가 지워지지 않는다. ( 1차 캐시에는 아무런 영향을 주지 않는다. )		
		> - flush 모드 옵션
		>		- `FlushMode.AUTO` : 커밋이나 쿼리를 실행할 때 플러시 (기본값)
		>		- `FlushMode.COMMIT` : 커밋할 때만 플러시

- **영속성 컨텍스트의 클리어 (Clear)**
	- `clear` 메서드를 사용하여 영속성 컨텍스트를 초기화합니다. 모든 영속 상태의 엔터티가 준영속 상태로 변환.


### **영속성 컨텍스트의 이점**

- 엔티티 조회 - 1차 캐시 **(First-Level Cache)**
	- 영속성 컨텍스트는 1차 캐시로서 엔터티를 캐싱합니다(Map).
	- 동일한 엔터티를 반복적으로 조회할 때 데이터베이스 접근을 줄이고 성능을 향상시킵니다.
	- 1차 캐시 내부에는 ( 엔티티 객체의 PK 정보, 엔티티 객체, 최초 1차 캐시에 들어온 시점의 엔티티 정보 ) 등이 있다.
	- 1차 캐시에 값이 없으면, DB에서 조회를 하고, 조회된 값을 1차 캐시에 저장한다. 그리고 그 저장된 값을 반환한다.
		- EntityManager 는 클라이언트 요청에 해당하는 트랜잭션 종료시 close 된다. 따라서, 1차 캐시는 하나의 트랜잭션 안에서만 적용된다.
- 엔티티 조회 - 동일성(identity) 보장
	- 영속성 컨텍스트는 동일한 트랜잭션 내에서 동일한 엔터티를 조회할 때 동일성을 보장
	- 이는 동일한 엔터티에 대한 여러 조회 결과가 동일한 객체 인스턴스를 참조
	- 1차 캐시를 사용하여 동일한 엔터티를 여러 번 조회할 때 동일한 인스턴스를 반환
	- 이를 통해 같은 엔터티에 대한 모든 변경 사항이 일관되게 유지
- 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연(Transactional write-behind)
	- 영속성 컨텍스트 안에는 1차 캐시 외에도 쓰기 지연 SQL 저장소라는 것이 존재
	- 쓰기 지연(Transactional Write-Behind)은 엔터티가 영속성 컨텍스트에 추가되거나 수정될 때, 즉시 데이터베이스에 반영하지 않고 트랜잭션이 커밋될 때까지 보류하는 메커니즘
	- `persist` 메서드를 호출하면 엔터티가 영속성 컨텍스트에 저장되지만, 실제 데이터베이스에 반영되지 않는다. →트랜잭션이 커밋될 때 모든 변경 사항이 데이터베이스에 반영. 이를 통해 여러 변경 사항을 하나의 트랜잭션 내에서 효율적으로 처리할 수 있습니다.
- 엔티티 수정 - 변경 감지(Dirty Checking)
	- 변경 감지(Dirty Checking)는 영속성 컨텍스트가 엔터티의 상태 변화를 감지하고, 트랜잭션 커밋 시 변경된 부분만 데이터베이스에 반영하는 기능
	- 영속 상태의 엔터티가 변경되면, 영속성 컨텍스트는 원본 상태와 현재 상태를 비교하여 변경 사항을 감지→ 트랜잭션이 커밋될 때 변경된 필드만 데이터베이스에 업데이트
		- 트랜잭션이 커밋되는 시점에 내부적으로 flush() 가 호출된다.
		- 플러시 발생시, 1차 캐시 내부에 엔티티와 스냅샷(최초로 1차 캐시에 값이 들어온 시점의 상태)을 비교한다. (변경 감지)
		- 비교한 값이 일치하지 않은 경우(=변경된 경우), UPDATE SQL 을 생성하여 쓰기 지연 SQL 저장소에 만들어둔다. 그리고 이를 데이터베이스에 전달하여 반영하고 커밋한다.
- 지연 로딩(Lazy Loading)
	- 지연 로딩(Lazy Loading)은 연관된 엔터티를 실제로 필요한 시점에 로딩하는 기법. 이는 성능 최적화를 위해 사용되며, 불필요한 데이터 로딩을 방지
	- 연관된 엔터티가 처음 접근될 때까지 데이터베이스 쿼리를 실행하지 않는다.
		- 연관 엔터티가 실제로 필요할 때 데이터베이스에서 로딩
			- 이를 통해 초기 데이터 로딩 시간을 줄이고 성능을 향상시킬 수 있습니다.

---


인용) 김영한 강사님 **자바 ORM 표준 JPA 프로그래밍 - 기본편**

